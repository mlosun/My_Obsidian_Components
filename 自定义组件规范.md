
自定义组件是 components 3.0 引入的一个全新的组件类型，该组件支持实时渲染 React JSX 组件代码。

自定义组件由 3 个独立部分组成

1. 视图源码：这部分代码决定了组件的样式和功能，采用 JSX 语法编写
2. 设置项源码：这部分点啊决定了组件的配置表单的样式和功能，采用 JSX 语法编写
3. CSS： 视图源码和设置项源码可以引用 css 中定义的 css class

## 组件规范

- **必须**：视图源码和设置项源码均使用 [JSX](https://react.dev/learn/writing-markup-with-jsx) 语法编写，使用 javascript 的语法，不能使用 typescript 的语法
- **必须**：视图源码和设置项源码必须包含一个名为 `App` 的函数

```jsx

function App() {
	return <div>Hello world</div>
}
```

- 不能使用 import 语法，但是可以直接使用 components 已经导出的 API（或 Hooks），详情参考 <API 列表> 和 <组件列表>

## 最佳实践

CSS 代码最佳实践

1. 视图和设置项的样式放在单独的 CSS 模块中维护
2. CSS 样式 优先使用 Obsidian 的 css variables，比如 `--background-primary`，`--background-modifier-border`, `--radius-m` 等
3. CSS class 或 animation 的命名增加自定义组件名称前缀，从而避免全局样式冲突，比如 `timeline--Title`
4. Obsidian 默认对 button、select 等组件添加了默认样式，如果你有自定义样式需求，为了确保样式能正确应用，需要通过添加级联元素来提高 css class 的优先级，比如 `button.timeline-ConfirmButton {} ` 
5. 样式设计要确保设计的一致性

组件代码最佳实践

1. 设置项源码优先使用 <组件列表> 中提供的组件，只有在经过评估后确定当前提供的组件不满足需求的情况下再自定义组件
2. 设置项的数据优先使用 `useDataStorage` 提供的方式进行数据保存和读取
3. 用户数据优先使用 `Files` 或 `Markdowns` 模块进行数据的读取和写入，更建议使用 `Markdowns` 将数据存储在 md 笔记文件中，比如打卡数据可以专门创建一个 `habit.md` 用来存放打卡记录
4. 优先使用 <API 列表> 中提供的功能 API，只有在经过评估后确定当前的 API 不满足需求再做扩展
5. 遵循 React 的最佳实践，比如使用 useCallback、useMemo 来封装函数和状态，避免 rerender 问题，要及时清理资源避免 OOM 等
6. 仔细检查状态依赖，避免造成无限循环的依赖更新问题，尤其是 useEffect 和 useState
7. 优先使用 Obsidian Plugin API 中提供的能力，比如 `Notice` 用于提示消息，`requestUrl` 用于发起网络请求, `MarkdownRenderer.render` 用于渲染 markdown
8. 组件设计遵循奥卡姆剃刀原则，如无必要，勿增实体

## 示例

以下示例展示了一个计数器的自定义组件，包含了 3 个部分的源码

### 视图源码

```jsx
function App() {
  const { getData, saveData } = useDataStorage();
  const app = useObsidianApp();
  const data = getData() || {};
  const settings = data.settings || {};
  const title = settings.title || "Custom Component Sample";
  const count = data.count ?? 0;
  
  return (
    <div className="sample--RootContainer">
      <h1>{title}</h1>
      <p>{count}</p>
      <div className="sample--ButtonContainer">
      <button onClick={() => saveData({ ...data, count: count + 1 })}>
        +1
      </button>
      <button onClick={() => saveData({ ...data, count: count - 1 })}>
        -1
      </button>
      </div>
  </div>
  );

```

### 设置项源码

```jsx
function App() {
    const { getData, saveData } = useDataStorage();
    const data = getData() || {};
    const settings = data.settings || {};
    return <Settings>
      <SettingInput 
        label="Title"
        value={settings.title || ""}
        placeholder="Enter title"
        type="text"
        onChange={(e) => saveData({ ...data, settings: { ...settings, title: e.target.value } })}
      />
      <SettingDescription>Configure your custom component here.</SettingDescription>
    </Settings>
}
```

### CSS

```css
.sample--RootContainer {
  padding: 20px;
  background-color: var(--background-primary-alt);
  border-radius: var(--radius-m);
}

.sample--ButtonContainer {
  display: flex;
  gap: 10px;
}
```

## API 列表

自定义组件可以通过 `模块名.xxx` 来调用指定模块下的 API，比如 `Tasks.getTasks()` 查询全库的任务， `Obsidian.requestUrl("https://google.com")` 发起网络请求

### React（模块）
`React` 模块中包含了 react 框架中常见的 hooks，比如 `React.useEffect`， `React.useState` 等。

为了方便 components 已经将常用的 hooks 直接导出，可以不用加 `React.` 前缀，列表如下

| Hooks       |
| ----------- |
| useState    |
| useEffect   |
| useCallback |
| useMemo     |
| useRef      |
| forwardRef  |

### Obsidian（模块）
`Obsidian` 模块包含了 obsidian 插件 API 中的所有能力。

> 查看 https://github.com/obsidianmd/obsidian-api/blob/master/obsidian.d.ts

比如可以通过 `Obsidian.requestUrl` 来发起网络请求

```js
export function htmlToMarkdown(html: string | HTMLElement | Document | DocumentFragment): string;


/**
 * Similar to `fetch()`, request a URL using HTTP/HTTPS, without any CORS restrictions.
 * Returns the text value of the response.
 * @public
 */
export function request(request: RequestUrlParam | string): Promise<string>;

/**
 * Similar to `fetch()`, request a URL using HTTP/HTTPS, without any CORS restrictions.
 * @public
 */
export function requestUrl(request: RequestUrlParam | string): RequestUrlResponsePromise;

/** @public */
export interface RequestUrlParam {
    /** @public */
    url: string;
    /** @public */
    method?: string;
    /** @public */
    contentType?: string;
    /** @public */
    body?: string | ArrayBuffer;
    /** @public */
    headers?: Record<string, string>;
    /**
     * Whether to throw an error when the status code is 400+
     * Defaults to true
     * @public
     */
    throw?: boolean;
}

/** @public */
export interface RequestUrlResponse {
    /** @public */
    status: number;
    /** @public */
    headers: Record<string, string>;
    /** @public */
    arrayBuffer: ArrayBuffer;
    /** @public */
    json: any;
    /** @public */
    text: string;
}

/** @public */
export interface RequestUrlResponsePromise extends Promise<RequestUrlResponse> {
    /** @public */
    arrayBuffer: Promise<ArrayBuffer>;
    /** @public */
    json: Promise<any>;
    /** @public */
    text: Promise<string>;
}
```

### Files（模块）

**文件操作工具模块** - 提供基础的文件创建、移动等操作功能。

**核心功能:**

- `createFile()` - 创建新文件，自动创建父目录
- `reateFileFromTemplate()` - 基于模板创建文件，支持模板内容复制
- `moveFile()` - 移动文件到目标文件夹，支持自动解决文件名冲突

**职责:** 封装 Obsidian 的文件系统操作，提供安全可靠的文件管理基础功能。

```js
/**
 * Create a new file from a template with template processing support.
 *
 * This function creates a new file and optionally applies a template with variable processing:
 * - If the file already exists, returns the existing file without modification
 * - Creates necessary parent directories if they don't exist
 * - Support Template variables include {{date}} {{time}} for date/time and {{title}} for file basename
 * - {{date}} and {{time}} can be formatted, use moment formatting, e.g. {{date:YYYY-MM-DD}} or {{time:HH:mm}}
 *
 * @param app The Obsidian app instance (required).
 * @param filePath The path of the file to create (required).
 * @param templateFilePath The path of the template file to use (optional). If not provided, creates an empty file.
 * @returns A promise that resolves to the created or existing file, see type {@link TFile}
 * @throws Error if the template file is specified but not found.
 */
export declare function createFileFromTemplate(app: App, filePath: string, templateFilePath?: string): Promise<TFile>;
/**
 * Create a new file in the vault.
 * @param app The Obsidian app instance (required).
 * @param filePath The path of the file to create (required).
 * @param content The initial content of the file (optional).
 * @returns The created file, type TFile
 */
export declare function createFile(app: App, filePath: string, content?: string): Promise<TFile>;
/**
 * move source file to target folder,
 *
 * if autoResolveNameConflict is true, when file name conflict, rename the file by appending _1, _2, ... to the base name
 * @param app
 * @param sourceFilePath
 * @param targetFolderPath
 * @param autoResolveNameConflict
 * @returns
 */
export declare function moveFile(app: App, sourceFilePath: string, targetFolderPath: string, autoResolveNameConflict?: boolean): Promise<void>;


```

### Markdowns（模块）

**Markdown 内容操作模块** - 专门处理 Markdown 文件的内容读取、编辑和标题操作。

**核心功能:**

- `readFileContent()` / `readContentUnderHeading()` - 读取文件内容或特定标题下的内容
- `appendContent()` / `prependContent()` - 在文件末尾或开头添加内容
- `appendContentUnderHeading()` / `prependContentUnderHeading()` - 在指定标题下添加内容
- `replaceContentUnderHeading()` - 替换标题下的内容
- 标题解析工具函数（解析级别、去除 Markdown 标记等）

**职责:** 提供精确的 Markdown 文档内容操作能力，支持按标题结构进行内容管理，自动处理前言块。

```js
/**
 * Heading location information
 */
declare type HeadingLocation = {
    /** Heading text, e.g. "## My Heading" */
    heading: string;
    /** Whether to include subheading content, default is false */
    includeSubHeadings?: boolean;
};
/**
 * read the content of a file, excluding frontmatter
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @returns The file content without frontmatter.
 */
export declare function readFileContent(app: App, filePath: string): Promise<string>;
/**
 * Read the content under a specified heading.
 *
 * The function locates the target heading and extracts content from its section:
 * - If includeSubHeadings is false: returns content until the next heading at any level
 * - If includeSubHeadings is true: returns content until the next heading at same or higher level
 * - If no next heading exists: returns content until end of file
 * - Returns empty string if heading not found or no metadata cache available
 *
 * @param app The Obsidian app instance
 * @param filePath The path to the markdown file
 * @param heading The heading location information
 * @returns The content under the heading, preserving original formatting
 */
export declare function readContentUnderHeading(app: App, filePath: string, heading: HeadingLocation): Promise<string>;
/**
 * Append content at the end of the specified heading section.
 *
 * The function locates the target heading and inserts content at the end of its section:
 * - If includeSubHeadings is false: insert before the next heading at any level
 * - If includeSubHeadings is true: insert before the next heading at same or higher level
 * - If no next heading exists: insert at the end of file
 * - If target heading section is empty: automatically adds a newline after content
 *
 * @param app The Obsidian app instance
 * @param filePath The path to the markdown file
 * @param heading The heading location information
 * @param content The content to insert. You control formatting including newlines.
 */
export declare function appendContentUnderHeading(app: App, filePath: string, heading: HeadingLocation, content: string): Promise<void>;
/**
 * Prepend content at the beginning of the specified heading section.
 *
 * The function locates the target heading and inserts content immediately after it:
 * - Always inserts at the beginning of heading content (includeSubHeadings is ignored)
 * - Inserts right after the heading line, before any existing content
 * - If next heading immediately follows target heading: automatically adds newline after content
 * - If at end of file: inserts at file end
 *
 * @param app The Obsidian app instance
 * @param filePath The path to the markdown file
 * @param heading The heading location information
 * @param content The content to insert. You control formatting including newlines.
 */
export declare function prependContentUnderHeading(app: App, filePath: string, heading: HeadingLocation, content: string): Promise<void>;
/**
 * replace the content under a specified heading, if include subheadings is true, replace all content until the next heading with the same or higher level
 * @param app
 * @param filePath
 * @param heading
 * @param content
 * @returns
 */
export declare function replaceContentUnderHeading(app: App, filePath: string, heading: HeadingLocation, content: string): Promise<void>;
/**
 * insert content at the enf of the file
 *
 * you should add new line character (if necessary) at the beginning of the content if you want to insert as a new line
 *
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @param content The content to append.
 */
export declare function appendContent(app: App, filePath: string, content: string): Promise<void>;
/**
 * Prepend content at the beginning of the file, after frontmatter if exists.
 *
 * The function inserts content at the very beginning of the file content:
 * - If frontmatter exists: inserts immediately after the frontmatter block
 * - If no frontmatter: inserts at the beginning of the file
 * - Uses character-level positioning for precise insertion
 *
 * @param app The Obsidian app instance
 * @param filePath The path to the markdown file
 * @param content The content to insert. You control formatting including newlines.
 */
export declare function prependContent(app: App, filePath: string, content: string): Promise<void>;
```

### Tasks（模块）

**任务管理模块** - 提供 Markdown 文件中任务（待办事项）的查询、修改、删除和导航功能。

**核心功能:**

- `getTasks()` - 从页面数据仓库获取所有任务，返回包含位置信息的任务数组
- `modifyTask()` - 修改现有任务的完整内容，保持原有缩进和格式
- `setTaskStatus()` - 快速修改任务状态（如 `[ ]` 到 `[x]`），支持各种状态字符
- `deleteTask()` - 删除指定位置的任务
- `revealTaskInFile()` - 在编辑器中定位并高亮显示任务

**核心类型:**

- `Task` - 任务数据结构，包含编号、状态、文本、位置和文件路径等信息

**职责:** 作为任务系统的核心操作接口，提供对 Markdown 任务的精确操作能力。依赖页面数据仓库进行任务发现，使用正则表达式解析任务格式，支持缩进、引用块等复杂格式，确保任务修改时保持原有的文档结构。

**特色功能:** 智能保持任务的原始格式（缩进、前缀等），支持多行任务内容，提供精确的位置定位和文件内导航。

```js
/**
 * Get all tasks from the page data repository.
 * @returns An array of tasks, see type {@link Task}
 */
export declare function getTasks(): {
    number: number;
    parent: number;
    status: string;
    text: string;
    pos: Pos;
    filePath: string;
}[];
/**
 * Modify an existing task in a markdown file.
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @param taskPos The position of the task to modify. {@link Pos}
 * @param markdownTask The new markdown content for the task, such as  `- [ ] todo`
 */
export declare function modifyTask(app: App, filePath: string, taskPos: Pos, markdownTask: string): Promise<void>;
/**
 * Set the status of a task in a markdown file.
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @param taskPos The position of the task to modify. {@link Pos}
 * @param status The new status for the task. such as `-`, ` `, `x`, only one character allowed
 * @returns
 */
export declare function setTaskStatus(app: App, filePath: string, taskPos: Pos, status: string): Promise<void>;
/**
 * Delete a task from a markdown file.
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @param pos The position of the task to delete. {@link Pos}
 */
export declare function deleteTask(app: App, filePath: string, pos: Pos): Promise<void>;
/**
 * Reveal a task in a markdown file.
 * @param app The Obsidian app instance.
 * @param filePath The path to the markdown file.
 * @param pos The position of the task to reveal. {@link Pos}
 * @param newLeaf Whether to open the file in a new pane.
 */
export declare function revealTaskInFile(app: App, filePath: string, pos: Pos, newLeaf?: PaneType | boolean): void;

type Task = {

    /**
     * The unique identifier for the task.
     */
    number: number;

    /**
     * The unique identifier for the parent task, if any.
     */
    parent: number;

    /**
     * The status of the task, such as `-`, `x`
     */
    status: string;

    /**
     * The text of the task, such as `- [ ] todo`
     */
    text: string;

    /**
     * The position of the task in the file.
     */
    pos: Pos;

    filePath: string
}

/**
 * Describes a text range in a Markdown document.
 * @public
 */
export interface Pos {
    /**
     * Starting location.
     * @public
     */
    start: Loc;
    /**
     * End location.
     * @public
     */
    end: Loc;
}

/**
 * Location within a Markdown document
 * @public
 */
export interface Loc {
    /**
     * Line number.
     * @public
     */
    line: number;
    /**
     * Column number.
     * @public
     */
    col: number;
    /**
     * Number of characters from the beginning of the file.
     * @public
     */
    offset: number;
}
```

### DailyNotes（模块）

**日记管理模块** - 基于 Obsidian 日记插件配置，提供日记文件的创建、查询和管理功能。

**核心功能:**

- [getDailyNoteOptions()](vscode-file://vscode-app/Applications/Visual%20Studio%20Code%20-%20Insiders.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html) - 获取日记插件配置（文件夹、格式、模板等）
- [getAllDailyNotes()](vscode-file://vscode-app/Applications/Visual%20Studio%20Code%20-%20Insiders.app/Contents/Resources/app/out/vs/code/electron-browser/workbench/workbench.html) - 获取所有符合日记格式的文件
- `getDailyNote()` - 根据 ISO 日期查找特定日记文件
- `createDailyNote()` - 创建指定日期的日记，支持模板和嵌套目录

**职责:** 作为日记系统的核心接口，遵循 Obsidian 日记插件的配置规范，提供统一的日记文件管理能力。支持复杂的日期格式（如 `YYYY/MM/YYYY-MM-DD`）和模板应用。

```js
/**
 * Configuration options for Obsidian's daily notes plugin.
 */
export declare type DailyNoteOptions = {
    /**
     * Whether to automatically run daily notes creation.
     */
    autorun: boolean;
    /**
     * The folder where daily notes are stored. Empty string means root folder.
     */
    folder: string;
    /**
     * The date format for daily note file names, such as "YYYY-MM-DD" or "YYYY/MM/YYYY-MM-DD".
     */
    format: string;
    /**
     * The template file path to use when creating new daily notes. Empty string means no template.
     */
    template: string;
};
/**
 * Get all daily notes from the vault based on the daily notes plugin configuration.
 * @param app The Obsidian app instance.
 * @returns A promise that resolves to an array of daily note files, see type {@link TFile}
 */
export declare function getAllDailyNotes(app: App): Promise<TFile[]>;
/**
 * Get a specific daily note for the given ISO date.
 * @param app The Obsidian app instance.
 * @param isoDate The ISO date string in format "YYYY-MM-DD", such as "2025-01-01".
 * @returns A promise that resolves to the daily note file if found, or null if not found, see type {@link TFile}
 * @throws Error if the isoDate format is invalid.
 */
export declare function getDailyNote(app: App, isoDate: string): Promise<TFile | null>;
/**
 * Create a new daily note for the given ISO date based on the daily notes plugin configuration.
 * If the daily note already exists, returns the existing file. Creates necessary directories
 * and applies template if configured.
 * @param app The Obsidian app instance.
 * @param isoDate The ISO date string in format "YYYY-MM-DD", such as "2025-01-01".
 * @returns A promise that resolves to the created or existing daily note file, see type {@link TFile}
 * @throws Error if the isoDate format is invalid or file creation fails.
 */
export declare function createDailyNote(app: App, isoDate: string): Promise<TFile>;
/**
 * Get the configuration options from Obsidian's daily notes plugin.
 * @param app The Obsidian app instance.
 * @returns The daily notes plugin configuration options, see type {@link DailyNoteOptions}
 */
export declare function getDailyNoteOptions(app: App): DailyNoteOptions;

```

### useObsidianApp()

`useObsidianApp` 可以获取 obsidian 的 App 对象，通过 App 对象可以实现

- 对文件的读取、写入
- 对工作区的调整
- 获取已安装的插件、主题信息
- 执行命令
- 获取文件的索引信息（MetadataCache）
- ...

示例

```jsx
function App() {
	const app = useObsidianApp();
	return <div>{app.appId}</div>
}
```
### useDataStorage()
`useDataStorage` 是由 components 提供的组件级的数据存储方案，该 hooks 会返回一个对象，对象中有 getData 和 setData 两个函数，分别用于读取和写入数据。

存储和读取的数据每个组件是独立的，该 hooks 不支持跨组件读取和写入数据。

> 当数据发生变更时，components 会确保其自动更新


示例

```jsx
function App() {
  const { getData, saveData } = useDataStorage();
  const data = getData() || {};
  const count = data.count ?? 0;
  
  return (
    <div className="sample--RootContainer">
      <p>{count}</p>
      <div className="sample--ButtonContainer">
      <button onClick={() => saveData({ ...data, count: count + 1 })}>
        +1
      </button>
      <button onClick={() => saveData({ ...data, count: count - 1 })}>
        -1
      </button>
      </div>
  </div>
  );
}
```

### useInterval

`useInterval` 可以实现定时周期触发，需要传递两个参数：第一个是回调函数，第二个是周期间隔（单位毫秒）

- 示例：每隔一秒将 progress 自动加 1

```jsx
const [progress, setProgress] = useState(0);
useInterval(() => {
	setProgress(prev =>  prev+1);
}, 1000);
```


## 组件列表

### Settings

设置项的容器组件，所有字设置项会以列表形式布局排列

#### Props

```jsx
type Props = {
	children?: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>;
```

#### 示例

```jsx
function App() {
	const [showBorder, setShowBorder] = useState<boolean>(false);
	return (
		<Settings>
			<SettingSwitch
				label={"Show border"}
				value={showBorder}
				onChange={setShowBorder}
			/>
		</Settings>
	);
}
```

### SettingItem

基础设置项，可自定义 children 元素

#### Props
```jsx
type Props = {
	label: string;
	icon?: React.ReactNode;
	description?: string;
	children?: React.ReactNode;
	className?: string;
};
```

#### 示例

```jsx
function App() {
	return (
		<Settings>
			<SettingItem label="username">
				<input type="text" />
			</SettingItem>
		</Settings>
	);
}
```

### SettingInput

单行输入组件，可以配置 text、checkbox、number、password 等类型，需要指定 `type` 属性值

#### Props

```jsx
type Props = {
	label: string;
} & React.InputHTMLAttributes<HTMLInputElement>;
```

#### 示例

```jsx
function App() {
	const [value, setValue] = useState<string>("");
	return (
		<Settings>
			<SettingInput
				label={"name"}
				type="text"
				value={valu}
				placeholder={"enter..."}
				onChange={(e) => {
					setValue(e.target.value);
				}}
			/>
		</Settings>
	);
}
```

### SettingTitle

设置项标题组件

#### Props

```jsx

type Props = {
	children?: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>;
```

#### 示例

```jsx
function App() {
	return (
		<Settings>
			<SettingTitle>Heading</SettingTitle>
		</Settings>
	);
}
```

### SettingDescription

设置项描述组件

#### Props

```jsx
type Props = {
	children?: React.ReactNode;
} & React.HTMLAttributes<HTMLDivElement>;
```

#### 示例

```jsx
function App() {
	return (
		<Settings>
			<SettingDescription>This is a description</SettingDescription>
		</Settings>
	);
}
```

### SettingDivider

设置项分割线

#### 示例

```jsx
function App() {
	return (
		<Settings>
			<SettingDivider />
		</Settings>
	);
}
```

### SettingSwitch

开关设置组件

#### Props

```jsx
type Props = {
	label: string;
	value: boolean;
	icon?: React.ReactNode;
	onChange: (value: boolean) => void;
	disabled?: boolean;
};

```

```jsx
function App() {
	const [value, setValue] = useState<boolean>(false);
	return (
		<Settings>
			<SettingSwitch
				label={"Enable shadow"}
				value={enable}
				onChange={setEnable}
			/>
		</Settings>
	);
}
```

### SettingSelect

设置项下拉单选组件，适合简单的下拉选择使用场景

> 如果有候选值数据量较大请使用 SettingAutocomplete 组件替代

#### Props

```jsx
export type SelectOption = {
	label: string; // 后选项名称，用于展示
	value: string; // 后选项值
	icon?: React.ReactNode;
};

type Props = {
	label: string; // 设置项名称
	icon?: React.ReactNode; // 设置项图标
	value: string; // 当前下拉选中的值
	valueLabel?: string; // 默认情况会基于 value 在 options 中匹配 label，但是有些情况下需要自定义 value 显示的文案，那么就可以设置 valueLabel
	onChange: (value: string) => void; // 选中值变化时的回调函数
	options: SelectOption[]; // 后选项
};
```

#### 示例

```jsx

function App() {
	const [value, setValue] = useState<string>("");
	const options = [
		{ label: "Option 1", value: "option1" },
		{ label: "Option 2", value: "option2" },
		{ label: "Option 3", value: "option3" },
	];
	return (
		<Settings>
			<SettingSelect
				value={value}
				options={options}
				onChange={setValue}
				label={"First name"}
			/>
		</Settings>
	);
}
```

### SettingAutocomplete

支持自动补全的下拉组件，该组件采用了虚拟列表优化了性能，适合大量候选值的场景

#### Props

```jsx
type Props = {
	label: string; // 设置项明朝
	value: string; // 当前选中的值
	icon?: React.ReactNode; // 图标
	valueLabel?: string;  // 自定义的 value 文案
	onChange: (value: string) => void; // 值变化时的回调函数
	items: () => {
		id: string;
		value: string;
		label: string;
		icon?: React.ReactNode;
	}[]; // 用于获取候选值列表
	placeholder?: string;
};
```

#### 示例

```jsx
export function FileSettingAutocomplete(props: {
	label: string;
	value: string;
	icon?: ReactNode;
	onChange: (value: string) => void;
	placeholder?: string;
	filter?: (file: TFile) => boolean;
}) {
	const { label, placeholder, value, onChange } = props;
	const app = useObsidianApp();
	const getItems = useCallback(() => {
		return app.vault
			.getAllLoadedFiles()
			.filter((f) => f instanceof TFile)
			.filter((f) => {
				if (props.filter) {
					return props.filter(f as TFile);
				}
				return true;
			})
			.map((f) => {
				return {
					id: f.path,
					value: f.path,
					label: f.name,
					description: f.path,
				};
			});
	}, []);
	return (
		<SettingAutocomplete
			label={label}
			icon={props.icon}
			value={value}
			valueLabel={value}
			onChange={onChange}
			placeholder={placeholder}
			items={getItems}
		/>
	);
}
```

### FileSettingAutocomplete

#### Props

| 属性          | 类型                       | 说明                                        | 必填  |
| ----------- | ------------------------ | ----------------------------------------- | --- |
| label       | string                   | 标签名称                                      | 是   |
| value       | string                   | 当前值                                       | 是   |
| onChange    | (value: string) => void  | 更新回调函数，会在用户选择了候选列表的后选项、或者输入后按下回车时触发       | 是   |
| placeholder | string                   | 输入框占位符，用于引导用户输入                           | 否   |
| filter      | (file: TFile) => boolean | 文件过滤器，决定了候选列表中哪些文件可以显示，比如可以显示制定类型的文件在候选列表 | 否   |

#### 示例

```jsx
<FileSettingAutocomplete
	label={localInstance.file_path}
	value={component.file || ""}
	filter={(f) =>
		f.extension === "components" &&
		!nodes.includes(f.path)
	}
	onChange={(v) => {
		saveProps("file", v);
	}}
></FileSettingAutocomplete>
```

### FolderSettingAutocomplete

#### Props

| 属性          | 类型                      | 说明                                  | 必填  |
| ----------- | ----------------------- | ----------------------------------- | --- |
| label       | string                  | 标签名称                                | 是   |
| value       | string                  | 当前值                                 | 是   |
| onChange    | (value: string) => void | 更新回调函数，会在用户选择了候选列表的后选项、或者输入后按下回车时触发 | 是   |
| placeholder | string                  | 输入框占位符，用于引导用户输入                     | 否   |

#### 示例

```jsx
<FolderSettingAutocomplete
	label={localInstance.folder}
	value={options.targetFolder || ""}
	onChange={(path) => {
		onValueUpdate(path);
	}}
/>
```

### PropertySettingAutocomplete

#### Props

| 属性          | 类型                           | 说明                                                   | 必填  |
| ----------- | ---------------------------- | ---------------------------------------------------- | --- |
| label       | string                       | 标签名称                                                 | 是   |
| value       | string                       | 当前值                                                  | 是   |
| onChange    | (value: string) => void      | 更新回调函数，会在用户选择了候选列表的后选项、或者输入后按下回车时触发                  | 是   |
| placeholder | string                       | 输入框占位符，用于引导用户输入                                      | 否   |
| filter      | (property: Property) => void | 过滤器，决定了候选列表中哪些属性可以显示。property 包含了 `name` 和 `type` 属性 | 否   |
> Property.type 包含： "text" | "number" | "datetime" | "date" | "multitext" | "checkbox";
#### 示例

```jsx
<PropertySettingAutocomplete
	label={localInstance.original_property}
	value={property}
	filter={(prop) => {
		return true;
	}}
	onChange={(prop) => {
		setProperty(prop);
	}}
/>
```

### EchartsView
`EchartsView` 是基于 [echarts](https://echarts.apache.org/) 封装的图表组件，可以用来渲染 echarts 图表。

为了控制包大小，默认只导出了以下组件

```js
echarts.use([
			TitleComponent,
			TooltipComponent,
			GridComponent,
			DatasetComponent,
			LegendComponent,
			CalendarComponent,
			VisualMapComponent,
			HeatmapChart,
			BarChart,
			LineChart,
			PieChart,
			FunnelChart,
			RadarChart,
			TreeChart,
			CanvasRenderer,
			MarkLineComponent,
		]);
```

#### Props

```typescript
type EchartsViewProps = {
	option: echarts.EChartsCoreOption;
	onReady?: (api: echarts.ECharts) => void;
} & React.HTMLProps<HTMLDivElement>;
```


#### 示例

```jsx
function App() {
	const { getData, saveData } = useDataStorage();
	const app = useObsidianApp();
	const data = getData() || {};
	const settings = data.settings || {};

	return (
		<EchartsView
			option={{
				xAxis: {
					type: "category",
					data: ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
				},
				yAxis: {
					type: "value",
				},
				series: [
					{
						data: [150, 230, 224, 218, 135, 147, 260],
						type: "line",
					},
				],
			}}
			onReady={(echartsApi) => {
				// 可以获取到 echarts api，用于实现自定义的操作
			}}
			style={{
				height: "400px",
			}}
		/>
	);
}

```


### ColorPicker

颜色选择器组件，点击后会显示色彩面板，用户可在该面板选择制定的颜色

#### Props

```jsx
type Props = {
	label?: string; // 颜色选择器旁边的文案
	color?: string; // 当前选中的颜色，hex 值
	defaultColor?: string; // 默认的颜色，hex 值
	enableGradient?: boolean; // 是否启用渐变色，启用后用户可以选择渐变色
	enableValueInput?: boolean; // 是否启用输入框，启用后会在颜色单元格旁边显示一个输入框，显示当前的色彩 hex 值，用户也可以实时修改
	onChange: (color?: string) => void; // 当颜色变化时的回调函数
	onReset?: (color?: string) => void; // 重置色彩的回调函数，配置了该函数后，会在色彩单元格右侧显示一个 X 按钮，用于重置色彩位 defaultColor
};
```

#### 示例

```jsx
function App() {
	const [color, setColor] = useState<string>("");
	const [darkColor, setDarkColor] = useState<string>("");
	return (
		<Settings>
			<SettingItem label={localInstance.background_color}>
				<ColorPicker
					label={"Light"}
					color={color}
					enableGradient={true}
					onChange={setColor}
				/>

				<ColorPicker
					label={"Dark"}
					color={darkColor}
					enableGradient={true}
					onChange={setDarkColor}
				/>
			</SettingItem>
		</Settings>
	);
}
```

### LucideIcon

可以根据 https://lucide.dev/icons/ 的 ICON 名称来渲染图标

#### Props

```jsx
type Props = {
	name: string; // ICON 名称，必填
	color?: string;  // ICON 颜色
	size?: number; // ICON 大小
};
```

#### 示例

```jsx
function App() {
	return <LucideIcon name={"calendar"} size={24} />
}
```


### LucideIconSuggestPanel

lucide icon 的选择面板，可用于直观的配置 icon

#### Props
```jsx

type props = {
	icon?: string;
	onChange: (icon?: string) => void;
}
```


#### 示例


```jsx
function App() {
	const [icon, setIcon] = useState<string>("");
	return <SettingItem label={"icon"}>
				<LucideIconSuggestPanel
					icon={icon}
					onChange={(icon) => {
						setIcon(icon)
					}}
				/>
			</SettingItem>
}
```
